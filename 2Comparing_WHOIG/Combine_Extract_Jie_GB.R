setwd('/Users/jiesun/Dropbox/PROJECT_JE/Comparing_WHOIG') #@@
library(ggplot2)
library(tidyr)

library(grid)
library(gridExtra)

# 1. Extract_Cases_Country.R =============================

# NOTE #
# Extract and compare cases between RF and WHO-IG
# ---- #

cat('===== START [Extract_Cases_Country.R] =====\n')

# # Get directory of the script (this part only work if source the code, wont work if run directly in the console)
# # This can be set manually !!!
# script.dir <- dirname(sys.frame(1)$ofile)
# script.dir <- paste0(script.dir, '/')
# setwd(script.dir)

# Create folder to store the result (will show warnings if the folder already exists --> but just warning, no problem)
dir.create(file.path('Generate/GB'), showWarnings = TRUE) #@@

LinkData <- '/Users/jiesun/Dropbox/PROJECT_JE/Generate_Cases/' # Data folder is from the Generate_Cases part #@@

Extract_Values_Country <- function(DF_Vals, DF_Coords, Index){
  # Extract values of entire map based on their countries
  # DF_Vals: Dataframe containing values in entire map
  # DF_Coords: Dataframe containing pixel's index indicating which country it belongs to
  # Index: Name of index in DF_Coords
  # Index + DF_Coords has to match
  # Coords in DF_Vals + DF_Coords have to match
  # @@ SJ: adjusted the condition as dx is extremely small (1.82e-12), maybe due to small rounding
  
  result <- vector('list', length(Index))
  names(result) <- Index
  # Check Coord match
  dx <- abs(DF_Vals$x - DF_Coords$x)
  dy <- abs(DF_Vals$y - DF_Coords$y)
  if (dx < 1.9e-12 && dy == 0){ #@@adjusted here 
    for (idx.country in 1 : length(Index)){
      idx_point <- which(DF_Coords[[3]] == idx.country)
      if (length(idx_point) > 0){
        vals <- DF_Vals[[3]][idx_point]
        result[[idx.country]] <- vals
      }
    }
  }else{
    cat('COORDINATES DO NOT MATCH --> STOP!!!\n')
  }
  return(result)
}

# Read data from generated cases dataframe (from Generate Cases part)
Link_Generate_Cases_DF <- paste0(LinkData, 'Generate/Cases/GB/') #@@
ListFiles <- list.files(Link_Generate_Cases_DF) # Make sure that you have to run the Generate Cases part before run the Comparing part

##### Read Map data #####
Country_Index <- readRDS(paste0(LinkData, "Generate/Country_Index.Rds")) # index of countries
Coord_Regions_Final <- readRDS(paste0(LinkData, "Generate/Coord_Regions_Final.Rds")) # country index of each pixel
Cases.map <- readRDS(paste0(LinkData, "Generate/Cases/GB/", ListFiles[length(ListFiles)])) # Take total cases (index 101) #@@

Cases.map <- Extract_Values_Country(Cases.map, Coord_Regions_Final, Country_Index)
# Fix Low.NPL and High.NPL
Cases.map$NPL <- c(Cases.map$Low.NPL, Cases.map$High.NPL)
Cases.map$MAC <- NULL
Cases.map$Low.NPL <- NULL
Cases.map$High.NPL <- NULL
# Add HKG in CHN
Cases.map$CHN <- c(Cases.map$CHN, Cases.map$HKG)
Cases.map$HKG <- NULL

# Sum cases in all pixels
for (idx in 1 : length(Cases.map)){
  Cases.map[[idx]] <- sum(Cases.map[[idx]])
}

##### Read Modelling data #####
# Cases generated by Quan (WHO-IG)
Cases.mod <- readRDS("Quan_Result/no_vac_cases_gen_age_sum_or.rds") # year 1950 - 2015 --> 66 cols / 1600 rows --> 1600 FOI posteriors
for (i in 1 : length(Cases.mod)){
  Cases.mod[[i]] <- as.numeric(Cases.mod[[i]][,66])
}

# Adjust Low.CHN, High.CHN
Cases.mod$CHN <- Cases.mod$Low.CHN + Cases.mod$High.CHN
Cases.mod$Low.CHN <- NULL
Cases.mod$High.CHN <- NULL
# Adjust Low.IDN, High.IDN
Cases.mod$IDN <- Cases.mod$Low.IDN + Cases.mod$High.IDN
Cases.mod$Low.IDN <- NULL
Cases.mod$High.IDN <- NULL
# Adjust Low.IND, High.IND, Medium.IND
Cases.mod$IND <- Cases.mod$Low.IND + Cases.mod$Medium.IND + Cases.mod$High.IND
Cases.mod$Low.IND <- NULL
Cases.mod$High.IND <- NULL
Cases.mod$Medium.IND <- NULL
# Adjust Low.NPL, High.NPL
Cases.mod$NPL <- Cases.mod$Low.NPL + Cases.mod$High.NPL
Cases.mod$Low.NPL <- NULL
Cases.mod$High.NPL <- NULL
# Adjust total_TWN
names(Cases.mod)[which(names(Cases.mod) == 'total_TWN')] <- 'TWN'

# Mean cases in all elements (1600 FOIs --> 1600 results --> take means)
for (idx in 1 : length(Cases.mod)){
  Cases.mod[[idx]] <- mean(Cases.mod[[idx]])
}

##### Create DF Compare #####
Countries <- names(Cases.map)
df <- data.frame(country = Countries, mod = 0, map = 0)
df$country <- as.character(df$country)
for (idx in 1 : nrow(df)){
  country <- df$country[idx]
  df$map[idx] <- Cases.map[[which(names(Cases.map) == country)]]
  df$mod[idx] <- Cases.mod[[which(names(Cases.mod) == country)]]
}
df$map <- round(df$map)
df$mod <- round(df$mod)

# level_oiginal <- AUS BRN BTN RUS SGP TLS JPN LAO PRK PNG TWN LKA KHM PAK KOR MYS NPL THA MMR VNM PHL BGD IDN IND CHN
# lv <- c('AUS', 'BRN', 'BTN', 'TLS', 'RUS', 'SGP', 'LAO', 'PNG', 'KHM',
#         'LKA', 'PRK', 'TWN', 'NPL', 'MYS', 'PAK', 'KOR', 'MMR', 'THA', 'VNM',
#         'PHL', 'JPN', 'BGD', 'IDN', 'IND', 'CHN')
df$country <- factor(df$country, levels = unique(df$country[order(df$mod)]), ordered = TRUE) # order based on modelling values (WHO-IG)
# df$country <- factor(df$country, levels = lv, ordered = TRUE) # order based on mod values

df_long <- gather(df, method, cases, mod, map, factor_key = TRUE)
colnames(df_long) <- c('Country', 'Method', 'Cases')
df_long$Method <- as.character(df_long$Method)
df_long$Method[which(df_long$Method == 'mod')] <- 'WHO-IG'
df_long$Method[which(df_long$Method == 'map')] <- 'Mapping'

##### SUBPLOT #####
# Divided Manually based on the cases --> divided into subgroup in order to make easier to see the plot (y-axis varies alot between countries)
part1 <- levels(df$country)[1 : 6]
part2 <- levels(df$country)[7 : 17]
part3 <- levels(df$country)[18 : 23]
part4 <- levels(df$country)[24 : 25]

df_long$Part <- 0
df_long$Part[which(df_long$Country %in% part1)] <- 1
df_long$Part[which(df_long$Country %in% part2)] <- 2
df_long$Part[which(df_long$Country %in% part3)] <- 3
df_long$Part[which(df_long$Country %in% part4)] <- 4

color <- c("#009E73", "#CC79A7")
names(color) <- c('WHO-IG', 'Mapping')
colscale <- scale_fill_manual(name = 'Method', values = color)

p <- ggplot(df_long, aes(x = Country, y = Cases, fill = Method)) + 
  geom_bar(stat = 'identity', position = position_dodge(), alpha = 0.75) + colscale
p <- p + facet_wrap(~Part, scale = 'free_y', ncol = 1)
p <- p + theme(axis.text.x = element_text(angle = 90))
p <- p + ggtitle('Case Compare Mapping vs WHO Incidence Group \nGB') +  xlab('Countries') + ylab('Cases') #@@
p

cat('===== FINISH [Extract_Cases_Country.R] =====\n')
# SAVE FILE
ggsave(filename = 'Generate/GB/Cases_Comparison.png', width = 108*2.5, height = 72*2.5, units = 'mm', plot = p)


# 2. Extract_FOI_Country.R =============================

# NOTE #
# Extract FOI of entire map based on their countries and compare with WHO-IG --> Mapping FOI distribution is stored in the variable result.country
# Visualize in both density and boxplot
# Note that WHO-IG dont have HKG (may be included in CHN)
# Plot and save file
# ---- #


cat('===== START [Extract_FOI_Country.R] =====\n')

# # Get directory of the script (this part only work if source the code, wont work if run directly in the console)
# # This can be set manually !!!
# script.dir <- dirname(sys.frame(1)$ofile)
# script.dir <- paste0(script.dir, '/')
# setwd(script.dir)

# Create folder to store the result (will show warnings if the folder already exists --> but just warning, no problem)
dir.create(file.path('Generate/GB/FOI_GB/'), showWarnings = TRUE) #@@
Savepath <- 'Generate/GB/' #@@

LinkData <- '/Users/jiesun/Dropbox/PROJECT_JE/Generate_Cases/' # Data folder is from the Generate_Cases part #@@

Extract_Values_Country <- function(DF_Vals, DF_Coords, Index){
  # Extract values of entire map based on their countries
  # DF_Vals: Dataframe containing values in entire map
  # DF_Coords: Dataframe containing pixel's index indicating which country it belongs to
  # Index: Name of index in DF_Coords
  # Index + DF_Coords have to match
  # Coords in DF_Vals + DF_Coords have to match
  # @@ SJ: adjusted the condition as dx is extremely small (1.82e-12), maybe due to small rounding
  
  result <- vector('list', length(Index))
  names(result) <- Index
  # Check Coord match
  dx <- abs(DF_Vals$x - DF_Coords$x)
  dy <- abs(DF_Vals$y - DF_Coords$y)
  if (dx < 1.9e-12 && dy == 0){ #@@adjusted here 
    for (idx.country in 1 : length(Index)){
      idx_point <- which(DF_Coords[[3]] == idx.country)
      if (length(idx_point) > 0){
        vals <- DF_Vals[[3]][idx_point]
        result[[idx.country]] <- vals
      }
    }
  }else{
    cat('COORDINATES DO NOT MATCH --> STOP!!!\n')
  }
  return(result)
}

##### Read Estimated FOI Values from RF #####
FOI_Estimated <- read.csv(paste0(LinkData, "Data/Endemic_FOI_GB_Quantile_Regression_Full_Cov_400.csv"),sep = '\t')#@@
# FOI_Estimated <- read.csv(paste0(LinkData, "Data/Endemic_result_Full_Cov_TVT_Land_400.csv"),sep = '\t')
FOI_Estimated <- FOI_Estimated[,-1]

##### Read Country index data #####
Country_Index <- readRDS(paste0(LinkData, "Generate/Country_Index.Rds")) # index of countries
Coord_Regions_Final <- readRDS(paste0(LinkData, "Generate/Coord_Regions_Final.Rds")) # country index of each pixel

##### Extract FOI distribution for each Country #####
result.country <- Extract_Values_Country(FOI_Estimated, Coord_Regions_Final, Country_Index)
# Fix Low.NPL and High.NPL
result.country$Low.NPL <- c(result.country$Low.NPL, result.country$High.NPL)
names(result.country)[17] <- 'NPL'
result.country$MAC <- NULL
result.country$High.NPL <- NULL

# saveRDS(result.country, paste0(Savepath, 'Mapping_FOI_Distribution_Countries.Rds'))
saveRDS(result.country, paste0(Savepath, 'Mapping_FOI_Distribution_Countries_GB.Rds'))

##### Compare to VIMC Posterior: Only some countries required by VIMC #####
# LinkData <- '~/DuyNguyen/RProjects/Rstan_Quan/Result Posterior/Dec06/'
# Listdata <- list.files(LinkData)
# ListCountries <- substr(Listdata, 15, 17)
# Countries_unique <- unique(ListCountries)
# 
# for (idx.country in 1 : length(Countries_unique)){
#     country <- Countries_unique[idx.country]
#     cat('Processing', country, '...\n')
#     idx.list <- which(ListCountries == country)
#     if (length(idx.list) < 2){
#         dat1 <- readRDS(paste0(LinkData, Listdata[idx.list]))
#         if (length(dat1) < 1600){
#             dat1 <- dat1$lambda
#         }
#         dat1.name <- rep(substr(Listdata[idx.list], 15, 17), length(dat1))
#     }else{
#         dat1 <- vector('list', length(idx.list))
#         names(dat1) <- Listdata[idx.list]
#         dat1.name <- rep('temp', 1600 * length(idx.list)) # default 1 R_Stan Posterior has 1600 values
#         for (idx.idx.list in 1 : length(idx.list)){
#             dat1[[idx.idx.list]] <- readRDS(paste0(LinkData, Listdata[idx.list[idx.idx.list]]))
#             if (length(dat1[[idx.idx.list]]) < 1600){
#                 dat1[[idx.idx.list]] <- dat1[[idx.idx.list]]$lambda
#             }
#             dat1.name[((idx.idx.list-1)*1600 + 1) : (idx.idx.list*1600)] <- rep(substr(Listdata[idx.list[idx.idx.list]], 15, 21), 1600)
#         }
#         dat1 <- as.numeric(unlist(dat1))
#     }
#     dat2 <- result.country[[country]]
#     dat2.name <- rep('RF', length(dat2))
#     dat <- data.frame(xx = c(dat1, dat2), yy = c(dat1.name, dat2.name))
#     
#     p <- ggplot(dat,aes(x=xx, y = ..scaled.., fill = yy)) + geom_density(alpha=0.3, position="identity") + 
#         coord_cartesian(xlim=c(quantile(dat$xx, 0.005), quantile(dat$xx, 0.99)))
#     ggsave(filename = paste0('FOI_Dens_', country, '.png'), plot = p)
# }

##### Compare to Journal Posterior from Quan #####
posterior <- readRDS(paste0(LinkData, "Data/ende_24_regions_lambda_extr_or.rds"))
select_region <- c(1:6, 11:15, 19:24, 28:30, 32:40, 48) # Quan selection
posterior_select <- posterior[select_region, ]

Countries_unique <- unique(posterior_select$country)
result.posterior <- vector('list', length(Countries_unique))
names(result.posterior) <- Countries_unique

for (idx.country in 1 : length(Countries_unique)){
  country <- Countries_unique[idx.country]
  idx.posterior <- which(posterior_select$country == country)
  result.posterior[[idx.country]] <- unlist(posterior_select[idx.posterior, ]$lambda_extr)
}

##### PLOT DISTRIBUTION #####
All_Countries <- names(result.country)
for (country in All_Countries){
  cat('Processing', country, '...\n')
  if (country != 'HKG'){
    dat1 <- result.posterior[[which(names(result.posterior) == country)]]
    dat2 <- result.country[[which(names(result.country) == country)]]
    dat1.name <- rep('WHO-IG', length(dat1))
    dat2.name <- rep('Mapping', length(dat2))
    
    meandat <- data.frame(mean = c(mean(dat1), mean(dat2)), MeanType = c('WHO-IG', 'Mapping'))
    
    color <- c("#009E73", "#CC79A7")
    names(color) <- c('WHO-IG', 'Mapping')
    colmeanscale <- scale_color_manual(name = 'Mean', values = color)
    colscale <- scale_fill_manual(name = 'Method', values = color)
    
    dat <- data.frame(xx = c(dat1, dat2), Type = c(dat1.name, dat2.name))
  }else{
    cat('QUAN DOES NOT HAVE DATA FOR HKG (MAYBE COMBINE WITH CHN) --> SKIP\n')
    dat2 <- result.country[[which(names(result.country) == country)]]
    dat2.name <- rep('Mapping', length(dat2))
    meandat <- data.frame(mean = mean(dat2), MeanType = 'Mapping')
    color <- c("#CC79A7")
    names(color) <- c('Mapping')
    colmeanscale <- scale_color_manual(name = 'Mean', values = color)
    colscale <- scale_fill_manual(name = 'Method', values = color)
    dat <- data.frame(xx = dat2, Type = dat2.name)
  }
  
  p1 <- ggplot(dat,aes(x=xx, fill = Type)) + geom_density(alpha=0.3, position="identity") + colscale +
    geom_vline(aes(xintercept = mean, color = MeanType), data = meandat, linetype = 'twodash', size = 0.65) + colmeanscale +
    labs(title = paste0('FOI Distribution Comparison - ', country), y = 'Density') + 
    theme(axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank(),
          axis.title.x = element_blank(),
          axis.title.y = element_text(size = 14),
          legend.direction = 'horizontal',
          legend.justification = c(1,1), legend.position=c(1,1),
          legend.background = element_rect(fill = 'transparent'),
          plot.title = element_text(size = 16, face = 'bold'))
  # coord_cartesian(xlim=c(quantile(dat$xx, 0.001), quantile(dat$xx, 0.99)))
  
  p2 <- ggplot(dat, aes(x = Type, y = xx, fill = Type)) + geom_boxplot(alpha = 0.3) + coord_flip() + colscale + 
    theme(axis.text.y = element_blank(), 
          axis.ticks.y = element_blank(),
          legend.position = 'none',
          axis.title.y = element_text(size = 14),
          axis.title.x = element_text(size = 14),
          axis.text.x = element_text(size = 13)) + 
    labs(x = 'Method', y = 'FOI')
  
  p3 <- grid.arrange(p1, p2, ncol = 1, heights = c(2, 1))
  
  ggsave(filename = paste0('Generate/GB/FOI_GB/FOI_Dens_', country, '.png'), width = 108*2.5, height = 72*2.5, units = 'mm', plot = p3) #@@
  
}

cat('===== FINISH [Extract_FOI_Country.R] =====\n')

# 3. Extract_Pop_Country.R =============================

# This step does not use the data generated by my RF/GB/XGB models
# So I skipped it. The result will be the same as Quan's.

# 4. Extract_Cases_Country_RF.R =============================

# Note this will be applied to RF/GB/XGB

## NOTE ##
# Plot the barchart of cases generated by RF
# Quite the same with Extract_Cases_Country.R
## ---- ##



# cat('===== START [Extract_Cases_Country_RF.R] =====\n')
cat('===== START [Extract_Cases_Country_GB.R] =====\n') #@@

# # Get directory of the script (this part only work if source the code, wont work if run directly in the console)
# # This can be set manually !!!
# script.dir <- dirname(sys.frame(1)$ofile)
# script.dir <- paste0(script.dir, '/')
# setwd(script.dir)
# 
# Create folder to store the result (will show warnings if the folder already exists --> but just warning, no problem)
dir.create(file.path('Generate'), showWarnings = TRUE)

LinkData <- '/Users/jiesun/Dropbox/PROJECT_JE/Generate_Cases/' # Data folder is from the Generate_Cases part #@@

Extract_Values_Country <- function(DF_Vals, DF_Coords, Index){
  # Extract values of entire map based on their countries
  # DF_Vals: Dataframe containing values in entire map
  # DF_Coords: Dataframe containing pixel's index indicating which country it belongs to
  # Index: Name of index in DF_Coords
  # Index + DF_Coords has to match
  # Coords in DF_Vals + DF_Coords have to match
  # @@ SJ: adjusted the condition as dx is extremely small (1.82e-12), maybe due to small rounding
  
  result <- vector('list', length(Index))
  names(result) <- Index
  # Check Coord match
  dx <- abs(DF_Vals$x - DF_Coords$x)
  dy <- abs(DF_Vals$y - DF_Coords$y)
  if (dx < 1.9e-12 && dy == 0){ #@@adjusted here 
    for (idx.country in 1 : length(Index)){
      idx_point <- which(DF_Coords[[3]] == idx.country)
      if (length(idx_point) > 0){
        vals <- DF_Vals[[3]][idx_point]
        result[[idx.country]] <- vals
      }
    }
  }else{
    cat('COORDINATES DO NOT MATCH --> STOP!!!\n')
  }
  return(result)
}

# Read data from generated cases dataframe (from Generate Cases part)
Link_Generate_Cases_DF <- paste0(LinkData, 'Generate/Cases/GB/') #@@
ListFiles <- list.files(Link_Generate_Cases_DF)

##### Read Map data #####
Country_Index <- readRDS(paste0(LinkData, "Generate/Country_Index.Rds")) # index of countries
Coord_Regions_Final <- readRDS(paste0(LinkData, "Generate/Coord_Regions_Final.Rds")) # country index of each pixel
Cases.map <- readRDS(paste0(LinkData, "Generate/Cases/GB/", ListFiles[length(ListFiles)])) # Take total cases (index 101)

Cases.map <- Extract_Values_Country(Cases.map, Coord_Regions_Final, Country_Index)
# Fix Low.NPL and High.NPL
Cases.map$NPL <- c(Cases.map$Low.NPL, Cases.map$High.NPL)
Cases.map$MAC <- NULL
Cases.map$Low.NPL <- NULL
Cases.map$High.NPL <- NULL
# Add HKG in CHN
Cases.map$CHN <- c(Cases.map$CHN, Cases.map$HKG)
Cases.map$HKG <- NULL

# Sum cases in all pixels
for (idx in 1 : length(Cases.map)){
  Cases.map[[idx]] <- sum(Cases.map[[idx]])
}

# CREATE DATAFRAME TO PLOT
Countries <- names(Cases.map)
df <- data.frame(country = Countries, cases = 0)
df$country <- as.character(df$country)
for (idx in 1 : nrow(df)){
  country <- df$country[idx]
  df$cases[idx] <- Cases.map[[which(names(Cases.map) == country)]]
}
df$cases <- round(df$cases)

df$country <- factor(df$country, levels = unique(df$country[order(df$cases)]), ordered = TRUE) # order based on cases values

##### SUBPLOT #####
part1 <- levels(df$country)[1 : 6]
part2 <- levels(df$country)[7 : 16]
part3 <- levels(df$country)[17 : 23]
part4 <- levels(df$country)[24 : 25]

df$Part <- 0
df$Part[which(df$country %in% part1)] <- '[1] Below 400 Cases'
df$Part[which(df$country %in% part2)] <- '[2] 400 - 2000 Cases'
df$Part[which(df$country %in% part3)] <- '[3] 2000 - 20000 Cases'
df$Part[which(df$country %in% part4)] <- '[4] Above 20000 Cases'

p <- ggplot(df, aes(x = country, y = cases, label = country)) + 
  geom_bar(stat = 'identity', position = position_dodge(), alpha = 0.75, fill = '#17ad3a') + 
  geom_text(size = 3.5, position = position_stack(vjust = 0.5))
p <- p + theme(axis.text.x = element_text(angle = 90))
p <- p + facet_wrap(~Part, scale = 'free_y', ncol = 1)
p <- p + labs(x = 'Countries', y = 'Cases', title = 'Cases by Country \nGB') #@@
p <- p + theme(
  strip.text.x = element_text(size = 12),
  axis.title.x = element_text(size = 14),
  axis.title.y = element_text(size = 14),
  axis.text.x = element_text(size = 12),
  axis.text.y = element_text(size = 12)
)

p

# cat('===== FINISH [Extract_Cases_Country_RF.R] =====\n')
cat('===== FINISH [Extract_Cases_Country_GB.R] =====\n') #@@

# SAVE FILE
ggsave(filename = 'Generate/GB/Cases_GB.png', width = 108*2.5, height = 72*2.5, units = 'mm', plot = p) #@@
